<!DOCTYPE html>
<html lang="ja" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:url" content="https://k42um.github.io/PassVu/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="PassVu | さあ、衛星からの声を聞いてみよう">
    <meta property="og:description" content="人工衛星からの電波を受信するために、衛星を自動でトラッキングします。 観測地点の設定や予測期間、最小仰角でのフィルタリングも可能です。">
    <meta property="og:site_name" content="PassVu">
    <meta property="og:image" content="https://k42um.github.io/PassVu/thumbnail.png">
    <title>PassVu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" href="./favicon.ico">
    <style>
        /* 検索リストが多くの項目を保持できるように高さを調整 */
        #satellite-list-container {
            max-height: 40vh; /* 画面の高さの40%を最大値に */
        }
        /* スクロールバーのスタイルを（控えめに）適用 */
        #satellite-list-container::-webkit-scrollbar,
        /* 予測パスリストのスクロールバーにもスタイルを適用 */
        #pass-list-table-wrapper::-webkit-scrollbar {
            width: 8px;
        }
        #satellite-list-container::-webkit-scrollbar-track,
        #pass-list-table-wrapper::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #satellite-list-container::-webkit-scrollbar-thumb,
        #pass-list-table-wrapper::-webkit-scrollbar-thumb {
            background: #d1d5db; /* gray-300 */
            border-radius: 10px;
        }
        #satellite-list-container::-webkit-scrollbar-thumb:hover,
        #pass-list-table-wrapper::-webkit-scrollbar-thumb:hover {
            background: #9ca3af; /* gray-400 */
        }
        /* 選択されたパスリストの行のスタイル */
        .pass-list-row.selected {
            background-color: #dbeafe; /* blue-100 */
        }
        /* ローディングスピナー */
        .loader {
            border: 4px solid #f3f4f6; /* gray-100 */
            border-top: 4px solid #f3f4f6; /* gray-100 */
            border-right: 4px solid #3b82f6; /* blue-500 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        /* スピナーのアニメーションを修正 */
        @keyframes spin {
            0% { 
                transform: rotate(0deg); 
            }
            100% { 
                transform: rotate(360deg); 
            }
        }
        
    </style>
</head>
<body class="bg-gray-100 text-gray-800 font-sans flex flex-col min-h-full">

    <!-- ヘッダー -->
    <header class="bg-white shadow-md">
        <div class="container mx-auto px-6 py-4">
            <h1 class="text-3xl font-bold text-gray-900">PassVu</h1>
        </div>
    </header>

    <!-- メインコンテンツ -->
    <main class="container mx-auto px-6 py-8 mt-8 flex-grow flex flex-col">
        
        <!-- TLE 取得方法の選択 -->
        <div id="selection-ui" class="flex-grow flex flex-col justify-center mb-8">
            <div class="bg-white p-8 rounded-lg shadow-xl text-center">
                <!-- <h2 class="text-4xl font-bold text-gray-900 mb-2">PassVu</h2> -->
                <!-- <p class="text-lg text-gray-600 mb-10">衛星からのパスを受信してみませんか？</p> -->

                <div class="grid md:grid-cols-2 gap-6">
                    <!-- 選択肢 1: Celestrakから取得 -->
                    <button id="fetch-celestrak" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-6 px-8 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1">
                        <div class = "mb-6"></div>
                        <span class="text-3xl">CelesTrakから取得</span>
                        <p class="text-base text-white mt-3 font-normal">現在アクティブな衛星をトラッキングします<br>毎日0時と12時にCelesTrakより自動取得します</p>
                        <div class = "mb-6"></div>
                    </button>

                    <!-- 選択肢 2: TLEを手動で入力 -->
                    <button id="manual-tle" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-6 px-8 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1">
                        <div class = "mb-6"></div>
                        <span class="text-3xl">TLEを手動で入力</span>
                        <p class="text-base text-white mt-5 font-normal">TLEデータを手動で入力して衛星をトラッキングします</p>
                        <div class = "mb-6"></div>
                    </button>
                </div>
            </div>
        </div>

        <!-- 「戻る」ボタンと現在時刻 (変更) -->
        <div id="top-controls-container" class="hidden flex justify-between items-center mb-6">
            <button id="back-to-selection" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-300 self-start">
                &larr; 戻る
            </button>
            
            <div id="current-time-display" class="flex items-center text-lg text-gray-700 font-semibold">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span id="current-time-display-span">--:--:--</span>
            </div>
        </div>

        <!-- 入力UIコンテナ (最初は非表示) -->
        <div id="input-ui-container" class="hidden">

            <!-- フォーム 1: CelesTrakから検索 (最初は非表示) -->
            <div id="celestrak-form" class="hidden bg-white p-8 rounded-lg shadow-xl mb-8">
                <div class="flex justify-between items-center mb-1">
                    <h2 class="text-3xl font-semibold">CelesTrakから検索</h2>
                </div>

                <!-- 最終取得時刻 -->
                <div id="last-fetch-time-container" class="hidden flex items-center text-sm text-gray-500 mb-6">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>最終データ取得: <span id="last-fetch-time-display"></span></span>
                </div>


                <!-- ローディングスピナーと検索ボックス -->
                <div class="flex justify-center mb-4" id="loading-spinner">
                    <div class="loader"></div>
                </div>
                <p id="loading-text" class="text-center text-gray-600 mb-6">TLEデータを取得中...</p>
                
                <input type="text" id="satellite-search" class="w-full p-3 border border-gray-300 rounded-lg mb-4" placeholder="衛星名で検索..." disabled>

                <!-- 衛星リスト -->
                <div id="satellite-list-container" class="overflow-y-auto border border-gray-200 rounded-lg bg-gray-50">
                    <!-- 衛星リストがここに動的に挿入されます -->
                </div>

                <!-- 選択された衛星情報（確認用、デバッグ用） -->
                <div id="selected-satellite-info" class="mt-6 hidden">
                    <h3 class="text-xl font-semibold mb-2">選択中のTLE</h3>
                    <pre class="bg-gray-100 p-4 rounded-lg text-sm overflow-x-auto"></pre>
                </div>
            </div>

            <!-- フォーム 2: TLEを手動で入力 (最初は非表示) -->
            <div id="manual-tle-form" class="hidden bg-white p-8 rounded-lg shadow-xl mb-8">
                <h2 class="text-3xl font-semibold mb-6">TLEを手動入力</h2>
                <p class="text-gray-700 mb-4">TLE (3行形式 または 2行形式) を入力してください。</p>
                
                <!-- TLE入力エリア -->
                <textarea id="tle-input-area" class="w-full p-3 border border-gray-300 rounded-lg font-mono text-sm" rows="6" placeholder="Line 0 (Optional Title)
Line 1
Line 2"></textarea>
                
                <p id="manual-tle-error" class="text-red-500 mt-2 hidden">TLEの解析に失敗しました。フォーマットを確認してください。</p>

                <!-- 可視化ボタン -->
                <button id="visualize-manual-button" class="mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow transition duration-300">
                    可視化
                </button>
            </div>
        </div>

        <!-- 可視化エリア (最初は非表示) -->
        <div id="visualization-area" class="hidden bg-white p-8 rounded-lg shadow-xl">

        <!-- 衛星名 + SatNOGS DB + オプションボタン -->
        <div class="flex flex-row justify-between items-center mb-6">
            
            <!-- 左側：衛星名 ＋ SatNOGS DB -->
            <div class="flex flex-row items-center gap-4">
                <h2 id="satellite-display-name" class="text-4xl font-bold text-gray-900"></h2>

                <!-- SatNOGS DB ボタン -->
                <button id="satnogs-button" title="SatNOGS DBを開く" 
                    class="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-150">
                    <span class="text-sm font-semibold text-gray-700 px-1">SatNOGS DB</span>
                </button>
            </div>

            <!-- 右端：オプションボタン -->
            <button id="settings-button" title="オプション" 
                class="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-150">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-700" fill="none"
                    viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round"
                        d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </button>

        </div>


            <!-- 予測パスリスト -->
            <div id="pass-list-container" class="mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-semibold">予測パスリスト</h3>
                    <!-- 件数表示を分離 -->
                    <span id="pass-list-count" class="text-sm text-gray-600 bg-gray-100 px-3 py-1 rounded-full"></span>
                </div>
                
                <!-- スクロール可能なテーブルラッパー -->
                <div id="pass-list-table-wrapper" class="overflow-x-auto max-h-[40vh] overflow-y-auto border border-gray-200 rounded-lg">
                    <table id="pass-list-table" class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50 sticky top-0 z-10">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">AOS (開始)</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">MAX (最大仰角)</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">LOS (終了)</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration (継続時間)</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            <!-- パスリストの行がここに挿入されます -->
                        </tbody>
                    </table>
                </div>
                <p id="no-passes-message" class="text-gray-500 text-center mt-6 hidden"></p>
            </div>

            <!-- パス詳細 (最初は非表示) -->
            <div id="pass-detail-container" class="mt-10 hidden">
                <!-- ヘッダーとダウンロードボタン -->
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-2xl font-semibold">パス詳細</h3>
                    <div class="flex gap-3 items-center"> <!-- TRACKボタンのために items-center を追加 -->
                        <!-- TRACKボタンコンテナ -->
                        <span id="tracking-button-container">
                            <!-- ここにJSでTRACKボタンが挿入されます -->
                        </span>
                        
                        <button id="download-image-button" title="画像 (PNG) としてダウンロード" class="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-150">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                            </svg>
                        </button>
                        <button id="download-pdf-button" title="PDFとしてダウンロード" class="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition duration-150">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-red-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- ダウンロードエラー表示用 -->
                <p id="download-error-message" class="text-red-500 text-center mb-4 hidden"></p>

                <!-- AOS/MAX/LOS/Duration -->
                <div id="pass-detail-text" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8 items-stretch">
                    <!-- ここにAOS, MAX, LOS, Duration が挿入されます -->
                </div>

                <!-- グラフコンテナ -->
                <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                    <!-- 仰角グラフ (lg:col-span-3) -->
                    <div class="lg:col-span-3 bg-gray-50 p-4 rounded-lg shadow-inner relative">
                        <canvas id="pass-chart-canvas" class="w-full" height="150"></canvas>
                    </div>
                    
                    <!-- スカイパス (lg:col-span-2) -->
                    <div class="lg:col-span-2 bg-gray-50 p-4 rounded-lg shadow-inner flex justify-center items-center">
                        <canvas id="sky-pass-canvas" width="350" height="350"></canvas>
                    </div>
                </div>

            </div>
        </div>

    </main>
    
    <!-- フッター -->
    <footer class="bg-white shadow-inner mt-12 py-6">
        <div class="container mx-auto px-6 text-center text-gray-600 text-sm">
            &copy; 2025 <a href="https://github.com/k42um" target="_blank" rel="noopener noreferrer">k42uma</a>
        </div>
    </footer>

    <!-- 設定モーダル (最初は非表示) -->
    <div id="settings-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center z-50 p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-lg p-8">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-2xl font-semibold">オプション</h3>
                <button id="close-settings-button" title="閉じる" class="text-gray-400 hover:text-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <div class="space-y-6">
                <!-- 観測地点 -->
                <div>
                    <h4 class="text-lg font-medium text-gray-800 mb-3">観測地点</h4>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <div class="flex flex-col gap-2">
                            <label for="obs-lat" class="text-sm font-medium text-gray-700">緯度 (°) :</label>
                            <input type="number" id="obs-lat" value="36.11" step="0.1" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        </div>
                        <div class="flex flex-col gap-2">
                            <label for="obs-lon" class="text-sm font-medium text-gray-700">経度 (°) :</label>
                            <input type="number" id="obs-lon" value="140.10" step="0.1" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        </div>
                        <div class="flex flex-col gap-2">
                            <label for="obs-alt" class="text-sm font-medium text-gray-700">高度 (m) :</label>
                            <input type="number" id="obs-alt" value="60" step="10" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                        </div>
                    </div>
                </div>

                <!-- 予測設定 -->
                <div>
                    <h4 class="text-lg font-medium text-gray-800 mb-3">予測設定</h4>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div class="flex flex-col gap-2">
                            <label for="duration-select" class="text-sm font-medium text-gray-700">予測期間:</label>
                            <select id="duration-select" class="w-full p-2 border border-gray-300 rounded-lg text-sm bg-white">
                                <option value="1">1日</option>
                                <option value="3">3日</option>
                                <option value="7" selected>7日</option>
                                <option value="15">15日</option>
                                <option value="30">30日</option>
                            </select>
                        </div>
                        <div class="flex flex-col gap-2">
                            <label for="max-elevation-filter" class="text-sm font-medium text-gray-700">最小仰角:</label>
                            <select id="max-elevation-filter" class="w-full p-2 border border-gray-300 rounded-lg text-sm bg-white">
                                <option value="0">0°</option>
                                <option value="5" selected>5°</option>
                                <option value="10">10°</option>
                                <option value="15">15°</option>
                                <option value="20">20°</option>
                                <option value="30">30°</option>
                                <option value="45">45°</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- アクションボタン -->
            <div class="mt-8 text-right">
                <button id="apply-settings-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow transition duration-300">
                    設定を適用
                </button>
            </div>
        </div>
    </div>

    <!-- (変更) リアルタイム追跡モーダル -->
    <div id="tracking-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-80 flex items-center justify-center z-50 p-4 transition-opacity duration-300">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-xl p-8 text-center relative">
            
            <!-- 閉じるボタン -->
            <button id="close-tracking-modal-button" title="閉じる" class="absolute top-4 right-4 text-gray-400 hover:text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>

            <h3 class="text-2xl font-semibold mb-4">リアルタイム追跡</h3>
            
            <!-- 現在時刻 (変更) -->
            <div class="flex items-center justify-center text-xl text-gray-700 mb-6">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span id="tracking-modal-current-time">--:--:--</span>
            </div>

            <!-- AOS/MAX/LOS (追加) -->
            <div class="grid grid-cols-3 gap-4 mb-8">
                <div class="bg-blue-50 p-3 rounded-lg">
                    <span class="text-xs font-semibold text-blue-700 tracking-wider uppercase">AOS</span>
                    <p id="tracking-modal-aos-time" class="text-2xl font-bold text-blue-900 mt-1">--:--:--</p>
                </div>
                <div class="bg-green-50 p-3 rounded-lg">
                    <span class="text-xs font-semibold text-green-700 tracking-wider uppercase">MAX EL</span>
                    <p id="tracking-modal-max-el" class="text-2xl font-bold text-green-900 mt-1">--.-°</p>
                </div>
                <div class="bg-red-50 p-3 rounded-lg">
                    <span class="text-xs font-semibold text-red-700 tracking-wider uppercase">LOS</span>
                    <p id="tracking-modal-los-time" class="text-2xl font-bold text-red-900 mt-1">--:--:--</p>
                </div>
            </div>

            <!-- El/Az -->
            <div class="grid grid-cols-2 gap-6 mb-4">
                <!-- 仰角 -->
                <div class="bg-gray-100 p-6 rounded-lg">
                    <span class="text-sm font-semibold text-gray-600 tracking-wider uppercase">仰角 (El)</span>
                    <p id="tracking-modal-el" class="text-7xl font-bold text-gray-900 mt-2">--.-°</p>
                </div>
                <!-- 方位角 -->
                <div class="bg-gray-100 p-6 rounded-lg">
                    <span class="text-sm font-semibold text-gray-600 tracking-wider uppercase">方位 (Az)</span>
                    <p id="tracking-modal-az" class="text-7xl font-bold text-gray-900 mt-2">--.-°</p>
                </div>
            </div>
            <p id="tracking-modal-az-compass" class="text-3xl text-gray-700 font-light mb-6">（--）</p>

            <!-- 「追跡を停止」ボタンは削除 -->
        </div>
    </div>


    <!-- 描画・軌道計算ライブラリ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/satellite.js@4.1.4/dist/satellite.min.js"></script>

    <!-- 完全なJavaScriptコード -->
    <script>
        window.onload = async () => {

            // --- URLパラメータの解析 ---
            const urlParams = new URLSearchParams(window.location.search);
            const satelliteNameFromUrl = urlParams.get('satellite');

            // --- DOM要素の取得 ---
            const selectionUI = document.getElementById('selection-ui');
            const inputUIContainer = document.getElementById('input-ui-container');
            const visualizationArea = document.getElementById('visualization-area');
            const topControlsContainer = document.getElementById('top-controls-container'); // (変更)
            const backToSelectionButton = document.getElementById('back-to-selection');
            const currentTimeDisplaySpan = document.getElementById('current-time-display-span'); // (追加)

            const fetchCelestrakButton = document.getElementById('fetch-celestrak');
            const manualTleButton = document.getElementById('manual-tle');

            const celestrakForm = document.getElementById('celestrak-form');
            const loadingSpinner = document.getElementById('loading-spinner');
            const loadingText = document.getElementById('loading-text');
            const satelliteSearch = document.getElementById('satellite-search');
            const satelliteListContainer = document.getElementById('satellite-list-container');
            const selectedSatInfo = document.getElementById('selected-satellite-info');
            const lastFetchTimeContainer = document.getElementById('last-fetch-time-container');
            const lastFetchTimeDisplay = document.getElementById('last-fetch-time-display');

            const manualTleForm = document.getElementById('manual-tle-form');
            const tleInputArea = document.getElementById('tle-input-area');
            const visualizeManualButton = document.getElementById('visualize-manual-button');
            const manualTleError = document.getElementById('manual-tle-error');

            const satelliteDisplayName = document.getElementById('satellite-display-name');
            const satnogsButton = document.getElementById('satnogs-button');
            const settingsButton = document.getElementById('settings-button');
            
            const passListContainer = document.getElementById('pass-list-container');
            const passListTableBody = document.querySelector('#pass-list-table tbody');
            const passListCount = document.getElementById('pass-list-count');
            const noPassesMessage = document.getElementById('no-passes-message');

            const passDetailContainer = document.getElementById('pass-detail-container');
            const passDetailText = document.getElementById('pass-detail-text');
            const trackingButtonContainer = document.getElementById('tracking-button-container'); // TRACKボタンコンテナ
            const passChartCanvas = document.getElementById('pass-chart-canvas');
            const skyPassCanvas = document.getElementById('sky-pass-canvas');
            const passChartCtx = passChartCanvas.getContext('2d');
            const skyPassCtx = skyPassCanvas.getContext('2d');
            
            const downloadImageButton = document.getElementById('download-image-button');
            const downloadPdfButton = document.getElementById('download-pdf-button');
            const downloadErrorMessage = document.getElementById('download-error-message');

            const settingsModal = document.getElementById('settings-modal');
            const closeSettingsButton = document.getElementById('close-settings-button');
            const applySettingsButton = document.getElementById('apply-settings-button');
            const durationSelect = document.getElementById('duration-select');
            const maxElevationFilter = document.getElementById('max-elevation-filter');
            const obsLatInput = document.getElementById('obs-lat');
            const obsLonInput = document.getElementById('obs-lon');
            const obsAltInput = document.getElementById('obs-alt'); 

            // --- (変更) リアルタイム追跡モーダル ---
            const trackingModal = document.getElementById('tracking-modal');
            const closeTrackingModalButton = document.getElementById('close-tracking-modal-button');
            // const stopTrackingButton = document.getElementById('stop-tracking-button'); // 削除
            const trackingModalEl = document.getElementById('tracking-modal-el');
            const trackingModalAz = document.getElementById('tracking-modal-az');
            const trackingModalAzCompass = document.getElementById('tracking-modal-az-compass');
            const trackingModalCurrentTime = document.getElementById('tracking-modal-current-time'); // (IDをspanに移したので、JSは変更不要)
            const trackingModalAosTime = document.getElementById('tracking-modal-aos-time'); // (追加)
            const trackingModalMaxEl = document.getElementById('tracking-modal-max-el'); // (追加)
            const trackingModalLosTime = document.getElementById('tracking-modal-los-time'); // (追加)

            // --- 状態管理変数 ---
            let allSatellites = []; 
            let isDataFetched = false; 
            let selectedTLE = { name: '', line1: '', line2: '' }; 
            let currentPasses = []; 
            let passTrackingTimer = null; // TRACK機能
            let realTimeTrackerInterval = null; // (追加) リアルタイム追跡用
            let currentSatrec = null; // (追加)
            let currentObserverGd = null; // (追加)
            let currentSelectedPass = null; // (追加)
            
            // --- イベントリスナー ---

            fetchCelestrakButton.addEventListener('click', async () => {
                showInputUI('celestrak');
                await checkAndFetchTLEData(); 
            });

            manualTleButton.addEventListener('click', () => {
                showInputUI('manual');
            });

            backToSelectionButton.addEventListener('click', () => {
                showSelectionUI();
            });

            satelliteSearch.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                const filteredSats = allSatellites.filter(sat => sat.name.toLowerCase().includes(query));
                displaySatellites(filteredSats);
            });

            visualizeManualButton.addEventListener('click', () => {
                const tleString = tleInputArea.value;
                const parsed = parseTLE(tleString);

                manualTleError.classList.add('hidden');
                if (parsed.line1 && parsed.line2) {
                    selectedTLE = parsed;
                    if (updateVisualizationArea()) { 
                        showVisualizationArea();
                    }
                } else {
                    manualTleError.classList.remove('hidden');
                }
            });

            satnogsButton.addEventListener('click', () => {
                const satnum = currentSatrec?.satnum;
                const url = `https://db.satnogs.org/satellite/${satnum}`;
                window.open(url, '_blank');
            });


            settingsButton.addEventListener('click', () => {
                settingsModal.classList.remove('hidden');
            });

            closeSettingsButton.addEventListener('click', () => {
                settingsModal.classList.add('hidden');
            });

            applySettingsButton.addEventListener('click', () => {
                updateVisualizationArea(); 
                settingsModal.classList.add('hidden');
            });
            
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    settingsModal.classList.add('hidden');
                }
            });

            downloadImageButton.addEventListener('click', downloadPassDetailAsImage);
            downloadPdfButton.addEventListener('click', downloadPassDetailAsPDF);

            // --- (変更) リアルタイム追跡モーダルリスナー ---
            closeTrackingModalButton.addEventListener('click', stopRealTimeTracking);
            // stopTrackingButton.addEventListener('click', stopRealTimeTracking); // 削除
            trackingModal.addEventListener('click', (e) => {
                if (e.target === trackingModal) {
                    stopRealTimeTracking();
                }
            });


            // --- 起動時処理 (URLパラメータチェック & 時刻表示) --- (変更)
            
            // リアルタイム時刻表示を開始 (追加)
            function updateCurrentTime() {
                const now = new Date();
                currentTimeDisplaySpan.textContent = formatTimeJST(now, true) + " (JST)";
            }
            updateCurrentTime(); // 即時実行
            setInterval(updateCurrentTime, 1000); // 1秒ごとに更新


            if (satelliteNameFromUrl) {
                showInputUI('celestrak');
                await checkAndFetchTLEData(satelliteNameFromUrl);
            }
            
            // --- 画面切り替え関数 --- (変更)

            function showSelectionUI() {
                selectionUI.classList.remove('hidden');
                inputUIContainer.classList.add('hidden');
                visualizationArea.classList.add('hidden');
                topControlsContainer.classList.add('hidden'); // (変更)
                resetForms();
                
                if (window.history.pushState) {
                    const cleanUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;
                    window.history.pushState({path: cleanUrl}, '', cleanUrl);
                }
            }

            function showInputUI(mode) {
                selectionUI.classList.add('hidden');
                inputUIContainer.classList.remove('hidden');
                visualizationArea.classList.add('hidden');
                topControlsContainer.classList.remove('hidden'); // (変更)
                
                if (mode === 'celestrak') {
                    celestrakForm.classList.remove('hidden');
                    manualTleForm.classList.add('hidden');
                } else if (mode === 'manual') {
                    celestrakForm.classList.add('hidden');
                    manualTleForm.classList.remove('hidden');
                }
            }

            function showVisualizationArea() {
                selectionUI.classList.add('hidden');
                inputUIContainer.classList.add('hidden');
                visualizationArea.classList.remove('hidden');
                topControlsContainer.classList.remove('hidden'); // (変更)
            }

            function resetForms() {
                satelliteSearch.value = '';
                if (isDataFetched) {
                    displaySatellites(allSatellites);
                }
                selectedSatInfo.classList.add('hidden');
                selectedSatInfo.querySelector('pre').textContent = '';

                tleInputArea.value = '';
                manualTleError.classList.add('hidden');
                
                selectedTLE = { name: '', line1: '', line2: '' }; 
                currentPasses = []; 
                clearPassDetails(); 
            }

            // --- CelesTrak関連関数 (キャッシュロジック修正) ---

            async function checkAndFetchTLEData(satelliteToSelect = null) {
                const cacheKey = 'tleDataCache';
                let cachedData = null;

                try {
                    cachedData = JSON.parse(localStorage.getItem(cacheKey));
                } catch (e) {
                    console.warn("LocalStorageのキャッシュ解析に失敗:", e);
                    cachedData = null;
                }

                if (cachedData && cachedData.data && isCacheValid(cachedData.timestamp)) {
                    loadingText.textContent = 'キャッシュからTLEデータを読込中...';
                    allSatellites = parseTLEData(cachedData.data);
                    isDataFetched = true;
                    displaySatellites(allSatellites);
                    displayLastFetchTime(cachedData.timestamp);
                    
                    loadingSpinner.classList.add('hidden');
                    loadingText.classList.add('hidden');
                    satelliteSearch.disabled = false;

                    if (satelliteToSelect) {
                        autoSelectSatelliteByName(satelliteToSelect);
                    }
                } else {
                    await fetchTLEData('active', satelliteToSelect);
                }
            }

            function isCacheValid(timestamp) {
                if (!timestamp) return false;

                const now = new Date();
                const cacheDate = new Date(timestamp);

                const isSameDay = now.toDateString() === cacheDate.toDateString();
                if (!isSameDay) return false;

                const nowHalf = now.getHours() < 12 ? 0 : 1; 
                const cacheHalf = cacheDate.getHours() < 12 ? 0 : 1; 

                return nowHalf === cacheHalf;
            }

            async function fetchTLEData(group, satelliteToSelect = null) {
                // celestrak.com に直接アクセス
                const url = `https://celestrak.com/NORAD/elements/gp.php?GROUP=${group}&FORMAT=tle`;
                
                loadingSpinner.classList.remove('hidden');
                loadingText.classList.remove('hidden');
                loadingText.textContent = 'TLEデータを取得中...';
                satelliteSearch.disabled = true;
                lastFetchTimeContainer.classList.add('hidden');

                try {
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        // 403 Forbiddenなどの場合、プロキシ経由で再試行
                        if (response.status === 403) {
                            throw new Error(`Direct access forbidden (403), retrying with proxy...`);
                        }
                        throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                    }
                    const tleData = await response.text();
                    
                    const currentTimestamp = new Date().getTime();

                    try {
                        const cachePayload = {
                            timestamp: currentTimestamp,
                            data: tleData
                        };
                        localStorage.setItem('tleDataCache', JSON.stringify(cachePayload));
                    } catch (e) {
                        console.warn("LocalStorageへのキャッシュ保存に失敗:", e);
                    }
                    
                    allSatellites = parseTLEData(tleData);
                    isDataFetched = true;
                    displaySatellites(allSatellites);
                    displayLastFetchTime(currentTimestamp);
                    
                    loadingSpinner.classList.add('hidden');
                    loadingText.classList.add('hidden');
                    satelliteSearch.disabled = false;
                    
                    if (satelliteToSelect) {
                        autoSelectSatelliteByName(satelliteToSelect);
                    }

                } catch (error) {
                    console.error('Error fetching TLE data:', error);
                    
                    if (error.message.includes("403") || error.message.includes("proxy")) {
                        loadingText.textContent = '直接アクセスが拒否されました。プロキシ経由で再試行します...';
                        await fetchTLEDataWithProxy(group, satelliteToSelect);
                    } else {
                        loadingText.textContent = `データの取得に失敗しました: ${error.message}`;
                        loadingSpinner.classList.add('hidden');
                    }
                }
            }

            async function fetchTLEDataWithProxy(group, satelliteToSelect = null) {
                // api.allorigins.win を使用
                const proxiedUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(`https://celestrak.org/NORAD/elements/gp.php?GROUP=${group}&FORMAT=tle`)}`;
                
                try {
                    const response = await fetch(proxiedUrl, { cache: 'no-cache' });
                    
                    if (!response.ok) {
                        throw new Error(`Proxy network response was not ok: ${response.status}`);
                    }
                    const tleData = await response.text();
                    
                    const currentTimestamp = new Date().getTime();

                    try {
                        const cachePayload = {
                            timestamp: currentTimestamp,
                            data: tleData
                        };
                        localStorage.setItem('tleDataCache', JSON.stringify(cachePayload));
                    } catch (e) {
                        console.warn("LocalStorageへのキャッシュ保存に失敗:", e);
                    }
                    
                    allSatellites = parseTLEData(tleData);
                    isDataFetched = true;
                    displaySatellites(allSatellites);
                    displayLastFetchTime(currentTimestamp); 
                    
                    loadingSpinner.classList.add('hidden');
                    loadingText.classList.add('hidden');
                    satelliteSearch.disabled = false;

                    if (satelliteToSelect) {
                        autoSelectSatelliteByName(satelliteToSelect);
                    }

                } catch (proxyError) {
                    console.error('Error fetching TLE data via proxy:', proxyError);
                    loadingText.textContent = `プロキシ経由での取得にも失敗しました: ${proxyError.message}`;
                    loadingSpinner.classList.add('hidden');
                }
            }

            function parseTLEData(data) {
                const lines = data.split('\n').filter(line => line.trim() !== '');
                const satellites = [];
                for (let i = 0; i < lines.length; i += 3) {
                    if (lines[i+1] && lines[i+2]) {
                        satellites.push({
                            name: lines[i].trim(),
                            line1: lines[i+1].trim(),
                            line2: lines[i+2].trim()
                        });
                    }
                }
                return satellites;
            }

            function parseTLE(data) {
                const lines = data.split('\n').filter(line => line.trim() !== '');
                let name = 'Untitled Satellite';
                let line1 = '';
                let line2 = '';

                if (lines.length === 2) {
                    line1 = lines[0].trim();
                    line2 = lines[1].trim();
                    const satNum = line1.substring(2, 7);
                    name = `SAT ${satNum}`;
                } else if (lines.length === 3) {
                    name = lines[0].trim();
                    line1 = lines[1].trim();
                    line2 = lines[2].trim();
                }

                if (!window.satellite) {
                     console.error("satellite.js がロードされていません。");
                     return { name: '', line1: '', line2: '' };
                }
                try {
                    const satrec = window.satellite.twoline2satrec(line1, line2);
                    if (satrec && !satrec.error) {
                         return { name, line1, line2 };
                    } else {
                        console.warn("TLEのパースに失敗 (satrec error):", satrec.error);
                        return { name: '', line1: '', line2: '' };
                    }
                } catch (e) {
                    console.error("TLEパース中に例外発生:", e);
                    return { name: '', line1: '', line2: '' };
                }
            }

            function displaySatellites(sats) {
                satelliteListContainer.innerHTML = '';
                if (sats.length === 0) {
                    satelliteListContainer.innerHTML = '<p class="p-4 text-center text-gray-500">該当する衛星はありません。</p>';
                    return;
                }

                const fragment = document.createDocumentFragment();
                sats.forEach(sat => {
                    const button = document.createElement('button');
                    button.className = "w-full text-left p-3 hover:bg-gray-200 transition duration-150";
                    button.textContent = sat.name;
                    button.addEventListener('click', () => {
                        selectSatellite(sat);
                    });
                    fragment.appendChild(button);
                });
                satelliteListContainer.appendChild(fragment);
            }

            function displayLastFetchTime(timestamp) {
                if (!timestamp) {
                    lastFetchTimeContainer.classList.add('hidden');
                    return;
                }
                const d = new Date(timestamp);
                const options = {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit',
                    timeZone: 'Asia/Tokyo', hour12: false
                };
                const formattedTime = new Intl.DateTimeFormat('ja-JP', options).format(d);
                lastFetchTimeDisplay.textContent = `${formattedTime} (JST)`;
                lastFetchTimeContainer.classList.remove('hidden');
            }

            function selectSatellite(sat) {
                selectedTLE = sat;

                selectedSatInfo.classList.remove('hidden');
                selectedSatInfo.querySelector('pre').textContent = `${sat.name}\n${sat.line1}\n${sat.line2}`;

                const buttons = satelliteListContainer.querySelectorAll('button');
                buttons.forEach(btn => {
                    if (btn.textContent === sat.name) {
                        btn.classList.add('bg-blue-100', 'font-semibold');
                    } else {
                        btn.classList.remove('bg-blue-100', 'font-semibold');
                    }
                });

                if (updateVisualizationArea()) {
                    showVisualizationArea();
                }
            }

            function autoSelectSatelliteByName(satelliteName) {
                if (!satelliteName || !allSatellites.length) {
                    return;
                }
                
                const normalizedName = satelliteName.toLowerCase();
                let foundSat = allSatellites.find(sat => sat.name.toLowerCase() === normalizedName);
                
                if (!foundSat) {
                    foundSat = allSatellites.find(sat => sat.name.toLowerCase().startsWith(normalizedName));
                }

                if (foundSat) {
                    selectSatellite(foundSat);
                } else {
                    satelliteSearch.value = satelliteName;
                    const filteredSats = allSatellites.filter(sat => sat.name.toLowerCase().includes(normalizedName));
                    displaySatellites(filteredSats);
                }
            }

            // --- 可視化エリア関数 ---

            function updateVisualizationArea() {
                satelliteDisplayName.textContent = selectedTLE.name;
                currentPasses = []; 
                clearPassDetails(); 
                noPassesMessage.classList.add('hidden'); 

                try {
                    if (!selectedTLE.line1 || !selectedTLE.line2) {
                        throw new Error("TLEが選択されていません。");
                    }
                    
                    if (!window.satellite) {
                        throw new Error("軌道計算ライブラリ(satellite.js)がロードされていません。");
                    }

                    const durationDays = parseInt(durationSelect.value, 10);
                    const obsLat = parseFloat(obsLatInput.value);
                    const obsLon = parseFloat(obsLonInput.value);
                    const obsAltM = parseFloat(obsAltInput.value); // (m)
                    const obsAltKm = obsAltM / 1000.0; // (km) に変換

                    if (isNaN(obsLat) || isNaN(obsLon) || isNaN(obsAltKm)) { 
                        throw new Error("緯度・経度・高度の値が無効です。");
                    }

                    // (変更) 観測地点とSatrecをグローバルに保存
                    currentObserverGd = {
                        latitude: window.satellite.degreesToRadians(obsLat),
                        longitude: window.satellite.degreesToRadians(obsLon),
                        height: obsAltKm // km単位
                    };

                    currentSatrec = window.satellite.twoline2satrec(selectedTLE.line1, selectedTLE.line2);
                    if (!currentSatrec || currentSatrec.error) {
                        let errorMsg = `Satrecの初期化に失敗しました。`;
                        if (currentSatrec.error) {
                            errorMsg += ` (Error code: ${currentSatrec.error})`;
                        }
                        currentSatrec = null;
                        throw new Error(errorMsg);
                    }


                    currentPasses = calculateRealPasses(currentSatrec, currentObserverGd, durationDays);

                    renderPassList();
                    
                    return true;

                } catch (error) {
                    console.error("軌道計算または表示の更新中にエラーが発生しました:", error);
                    
                    renderPassList(); 
                    noPassesMessage.textContent = `軌道計算エラー: ${error.message} (TLEデータが古いか、軌道が減衰した可能性があります)`;
                    noPassesMessage.classList.remove('hidden');
                    
                    return true; 
                }
            }

            // --- 軌道計算 (satellite.js) ---

            function calculateRealPasses(satrec, observerGd, durationDays) {
                // (変更) satrecの初期化を移動

                const allPasses = [];
                let currentPass = null;
                
                const now = new Date();
                const endTime = new Date(now.getTime() + durationDays * 24 * 60 * 60 * 1000);
                
                // (変更) スキャン開始時刻を現在時刻の30分前からに変更
                // これにより、現在進行中のパスの正しいAOSを検出する
                const scanStartTime = new Date(now.getTime() - 30 * 60 * 1000);
                
                const scanIntervalMinutes = 1;

                // (変更) ループの開始時刻を変更
                for (let d = new Date(scanStartTime.getTime()); d < endTime; d.setMinutes(d.getMinutes() + scanIntervalMinutes)) {
                    
                    const positionAndVelocity = window.satellite.propagate(satrec, d);
                    
                    if (!positionAndVelocity || !positionAndVelocity.position || !positionAndVelocity.velocity) {
                        console.warn(`[${selectedTLE.name}] at ${d.toISOString()}: 伝播エラー。計算を中止します。`);
                        throw new Error(`衛星[${selectedTLE.name}]の伝播(propagate)に失敗しました。`);
                    }
                    
                    const gmst = window.satellite.gstime(d);
                    const positionEcf = window.satellite.eciToEcf(positionAndVelocity.position, gmst);
                    
                    const lookAngles = window.satellite.ecfToLookAngles(observerGd, positionEcf);
                    
                    const elevation = window.satellite.radiansToDegrees(lookAngles.elevation);
                    const azimuth = window.satellite.radiansToDegrees(lookAngles.azimuth);

                    if (elevation >= 0) {
                        if (currentPass === null) {
                            currentPass = {
                                satellite: selectedTLE.name,
                                startTime: new Date(d.getTime()),
                                maxElevation: elevation,
                                maxElevationTime: new Date(d.getTime()),
                                maxElevationAz: azimuth,
                                endTime: null,
                                duration: 0,
                                timelineData: []
                            };
                        }
                        
                        currentPass.timelineData.push({
                            time: new Date(d.getTime()),
                            elevation: elevation,
                            azimuth: azimuth,
                            range: lookAngles.range 
                        });

                        if (elevation > currentPass.maxElevation) {
                            currentPass.maxElevation = elevation;
                            currentPass.maxElevationTime = new Date(d.getTime());
                            currentPass.maxElevationAz = azimuth;
                        }

                    } else {
                        if (currentPass !== null) {
                            currentPass.endTime = new Date(d.getTime() - scanIntervalMinutes * 60 * 1000);
                            currentPass.duration = (currentPass.endTime.getTime() - currentPass.startTime.getTime()) / (1000 * 60);
                            
                            // (変更) パスの終了時刻が「現在時刻」より未来のもの（＝まだ終わっていないパス）のみを追加
                            if (currentPass.duration >= 2 && currentPass.endTime.getTime() > now.getTime()) {
                                allPasses.push(currentPass);
                            }
                            currentPass = null;
                        }
                    }
                } 

                return allPasses;
            }


            // --- 表示レンダリング関数 ---

            function renderPassList() {
                passListTableBody.innerHTML = '';
                
                const minElevationFilterVal = parseFloat(maxElevationFilter.value);
                const filteredPasses = currentPasses.filter(pass => pass.maxElevation >= minElevationFilterVal);

                passListCount.textContent = `${filteredPasses.length} 件`;

                if (filteredPasses.length === 0) {
                    if (noPassesMessage.classList.contains('hidden')) {
                        noPassesMessage.textContent = `この条件（最小仰角 ${minElevationFilterVal}° 以上）に該当するパスは見つかりませんでした。`;
                        noPassesMessage.classList.remove('hidden');
                    }
                    return;
                }
                
                noPassesMessage.classList.add('hidden');
                
                const fragment = document.createDocumentFragment();
                filteredPasses.forEach(pass => {
                    const row = document.createElement('tr');
                    row.className = "pass-list-row cursor-pointer hover:bg-gray-100";
                    row.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="text-sm font-medium text-gray-900">${formatTimeJST(pass.startTime)}</div>
                            <div class="text-sm text-gray-500">${formatDateJST(pass.startTime)}</div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="text-sm font-medium text-gray-900">${pass.maxElevation.toFixed(1)}°</div>
                            <div class="text-sm text-gray-500">${formatTimeJST(pass.maxElevationTime)}</div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <div class="text-sm font-medium text-gray-900">${formatTimeJST(pass.endTime)}</div>
                            <div class="text-sm text-gray-500">${formatDateJST(pass.endTime)}</div>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700">${pass.duration.toFixed(0)} 分</td>
                    `;
                    
                    row.addEventListener('click', () => {
                        document.querySelectorAll('.pass-list-row.selected').forEach(r => {
                            r.classList.remove('selected');
                        });
                        row.classList.add('selected');
                        showPassDetails(pass);
                    });

                    fragment.appendChild(row);
                });
                passListTableBody.appendChild(fragment);
            }

            function showPassDetails(pass) {
                currentSelectedPass = pass; // (追加) 現在のパスを保存

                passDetailContainer.classList.remove('hidden');
                downloadErrorMessage.classList.add('hidden');
                
                const aosTime = pass.timelineData[0];
                const losTime = pass.timelineData[pass.timelineData.length - 1];

                // 4列のHTML
                passDetailText.innerHTML = `
                    <div class="bg-blue-100 p-4 rounded-lg shadow-inner h-full flex flex-col justify-evenly">
                        <span class="text-sm font-semibold text-blue-800 tracking-wider uppercase">AOS</span>
                        <span class="text-3xl font-bold text-blue-900">${formatTimeJST(pass.startTime, true)}</span>
                        <div class="text-sm text-blue-700">
                            <span>${aosTime.elevation.toFixed(1)}°</span> / 
                            <span>${aosTime.azimuth.toFixed(0)}° (${azToCompass(aosTime.azimuth)})</span>
                        </div>
                    </div>
                    <div class="bg-green-100 p-4 rounded-lg shadow-inner h-full flex flex-col justify-evenly">
                        <span class="text-sm font-semibold text-green-800 tracking-wider uppercase">MAX</span>
                        <span class="text-3xl font-bold text-green-900">${pass.maxElevation.toFixed(1)}°</span>
                        <div class="text-sm text-green-700">
                            <span>${formatTimeJST(pass.maxElevationTime, true)}</span>
                        </div>
                         <div class="text-sm text-green-700">
                            <span>${pass.maxElevationAz.toFixed(0)}° (${azToCompass(pass.maxElevationAz)})</span>
                        </div>
                    </div>
                    <div class="bg-red-100 p-4 rounded-lg shadow-inner h-full flex flex-col justify-evenly">
                        <span class="text-sm font-semibold text-red-800 tracking-wider uppercase">LOS</span>
                        <span class="text-3xl font-bold text-red-900">${formatTimeJST(pass.endTime, true)}</span>
                        <div class="text-sm text-red-700">
                            <span>${losTime.elevation.toFixed(1)}°</span> / 
                            <span>${losTime.azimuth.toFixed(0)}° (${azToCompass(losTime.azimuth)})</span>
                        </div>
                    </div>
                    <div class="bg-gray-100 p-4 rounded-lg shadow-inner h-full flex flex-col justify-evenly">
                        <span class="text-sm font-semibold text-gray-800 tracking-wider uppercase">Duration</span>
                        <span class="text-3xl font-bold text-gray-900">${pass.duration.toFixed(0)}</span>
                        <div class="text-sm text-gray-700">
                            <span>分</span>
                        </div>
                    </div>
                `;

                // --- リアルタイム追跡ボタンのロジック (アイコン削除) ---
                
                // 以前のタイマーをクリア
                if (passTrackingTimer) {
                    clearInterval(passTrackingTimer);
                    passTrackingTimer = null;
                }
                
                trackingButtonContainer.innerHTML = ''; // コンテナを初期化

                // 1秒ごとに現在時刻をチェックするタイマーを設定
                passTrackingTimer = setInterval(() => {
                    const now = new Date().getTime();
                    const startTime = pass.startTime.getTime();
                    const endTime = pass.endTime.getTime();

                    // 現在時刻がパスのAOSとLOSの間にあるか
                    if (now >= startTime && now <= endTime) {
                        // ボタンがまだ表示されていない場合のみ作成
                        if (trackingButtonContainer.innerHTML === '') {
                             trackingButtonContainer.innerHTML = `
                                <!-- (変更) buttonタグに変更 -->
                                <button id="track-button-dynamic" class="flex items-center gap-2 text-white font-bold py-2 px-3 rounded-lg text-sm transition duration-300" style="background-color: #d50019;">
                                    TRACK
                                </button>
                            `;
                            // (追加) ボタンにイベントリスナーを追加
                            document.getElementById('track-button-dynamic').addEventListener('click', startRealTimeTracking);
                        }
                    } else {
                        // パスが終了したか、まだ始まっていない場合
                        trackingButtonContainer.innerHTML = '';
                        // (追加) パスが終了したら、追跡モーダルも閉じる
                        if (now > endTime) {
                            if (passTrackingTimer) {
                                clearInterval(passTrackingTimer);
                                passTrackingTimer = null;
                            }
                            stopRealTimeTracking(); // モーダルを閉じる
                        }
                    }
                }, 1000); // 1秒ごとにチェック

                drawPassChart(pass);
                drawSkyPassChart(pass);

                passDetailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            function clearPassDetails() {
                // リアルタイム追跡タイマーを停止
                if (passTrackingTimer) {
                    clearInterval(passTrackingTimer);
                    passTrackingTimer = null;
                }
                
                stopRealTimeTracking(); // (追加) リアルタイム追跡を停止
                currentSelectedPass = null; // (追加)

                passDetailContainer.classList.add('hidden');
                passDetailText.innerHTML = '';
                trackingButtonContainer.innerHTML = ''; // コンテナをクリア
                downloadErrorMessage.classList.add('hidden');
                passChartCtx.clearRect(0, 0, passChartCanvas.width, passChartCanvas.height);
                skyPassCtx.clearRect(0, 0, skyPassCanvas.width, skyPassCanvas.height);
                document.querySelectorAll('.pass-list-row.selected').forEach(r => {
                    r.classList.remove('selected');
                });
            }

            // --- グラフ描画関数 (Canvas) ---

            function drawPassChart(pass) {
                const canvas = passChartCanvas;
                const ctx = passChartCtx;
                const timeline = pass.timelineData;
                
                if (!timeline || timeline.length === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }
                
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                
                if (rect.width === 0 || rect.height === 0) {
                    return;
                }

                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
                const width = rect.width;
                const height = rect.height; 

                ctx.clearRect(0, 0, width, height);

                const padding = { top: 40, right: 20, bottom: 40, left: 40 };
                const plotWidth = width - padding.left - padding.right;
                const plotHeight = height - padding.top - padding.bottom;

                const startTime = timeline[0].time;
                const endTime = timeline[timeline.length - 1].time;
                const timeRange = endTime.getTime() - startTime.getTime();
                
                const getX = (time) => {
                    if (timeRange === 0) return padding.left;
                    return padding.left + ((time.getTime() - startTime.getTime()) / timeRange) * plotWidth;
                };

                const getY = (el) => height - padding.bottom - (el / 90) * plotHeight;

                ctx.strokeStyle = '#e5e7eb';
                ctx.fillStyle = '#6b7281';
                ctx.font = '12px sans-serif';

                [0, 30, 60, 90].forEach(el => {
                    const y = getY(el);
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                    ctx.fillText(`${el}°`, padding.left - 25, y + 4);
                });

                const numTimeTicks = Math.min(5, timeline.length - 1);
                if (numTimeTicks > 0) {
                    for (let i = 0; i <= numTimeTicks; i++) {
                        const t = new Date(startTime.getTime() + (timeRange / numTimeTicks) * i);
                        const x = getX(t);
                        ctx.beginPath();
                        ctx.moveTo(x, padding.top);
                        ctx.lineTo(x, height - padding.bottom);
                        ctx.stroke();
                        const label = formatTimeJST(t);
                        ctx.fillText(label, x - (ctx.measureText(label).width / 2), height - padding.bottom + 20);
                    }
                }

                ctx.beginPath();
                ctx.moveTo(getX(timeline[0].time), getY(timeline[0].elevation));
                
                for (let i = 0; i < timeline.length - 1; i++) {
                    const p1 = timeline[i];
                    const p2 = timeline[i+1];
                    const x1 = getX(p1.time);
                    const y1 = getY(p1.elevation);
                    const x2 = getX(p2.time);
                    const y2 = getY(p2.elevation);
                    const midX = (x1 + x2) / 2;
                    ctx.quadraticCurveTo(x1, y1, midX, (y1 + y2) / 2);
                }
                const last = timeline[timeline.length - 1];
                ctx.lineTo(getX(last.time), getY(last.elevation));

                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.lineTo(getX(last.time), getY(0));
                ctx.lineTo(getX(timeline[0].time), getY(0));
                ctx.closePath();
                ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                ctx.fill();

                ctx.font = '11px sans-serif';
                const azRadius = 12; 
                const azY = padding.top - 20;

                if (plotWidth < 50) return;

                const azPoints = [];
                const step = Math.max(1, Math.floor(timeline.length / 10));
                for (let i = 0; i < timeline.length; i += step) {
                    azPoints.push(timeline[i]);
                }
                if (azPoints.length > 0 && azPoints[azPoints.length-1] !== timeline[timeline.length-1]) {
                    azPoints.push(timeline[timeline.length-1]);
                }

                azPoints.forEach((point) => {
                    const x = getX(point.time);
                    const az = point.azimuth;

                    ctx.save();
                    ctx.translate(x, azY);

                    ctx.beginPath();
                    ctx.arc(0, 0, azRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#f3f4f6';
                    ctx.strokeStyle = '#d1d5db';
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = '#4b5563';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`${az.toFixed(0)}°`, 0, 0);

                    ctx.rotate(window.satellite.degreesToRadians(az));
                    ctx.beginPath();
                    ctx.moveTo(0, -azRadius + 2);
                    ctx.lineTo(0, -azRadius - 6);
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.restore();
                });
            }

            function drawSkyPassChart(pass) {
                const canvas = skyPassCanvas;
                const ctx = skyPassCtx;
                const timeline = pass.timelineData;

                if (!timeline || timeline.length === 0) {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    return;
                }

                const dpr = window.devicePixelRatio || 1;
                const size = 350; 
                canvas.width = size * dpr;
                canvas.height = size * dpr;
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;

                ctx.scale(dpr, dpr);
                
                ctx.clearRect(0, 0, size, size);

                const center = size / 2;
                const maxRadius = size / 2 - 20;

                const getCoords = (el, az) => {
                    const radius = maxRadius * (1 - el / 90);
                    const angle = window.satellite.degreesToRadians(az - 90); 
                    
                    return {
                        x: center + radius * Math.cos(angle),
                        y: center + radius * Math.sin(angle)
                    };
                };

                ctx.strokeStyle = '#d1d5db';
                ctx.fillStyle = '#6b7281';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // 仰角ラベルを左にずらす (Nと重ならないように)
                [0, 30, 60].forEach(el => {
                    const r = maxRadius * (1 - el / 90);
                    ctx.beginPath();
                    ctx.arc(center, center, r, 0, 2 * Math.PI);
                    ctx.setLineDash([2, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.fillStyle = '#a1a1aa';
                    ctx.fillText(`${el}°`, center - 15, center - r);
                });
                ctx.fillText('90°', center - 15, center);

                ['N', 'E', 'S', 'W'].forEach((dir, i) => {
                    const angle = window.satellite.degreesToRadians(i * 90 - 90);
                    const x = center + (maxRadius + 10) * Math.cos(angle);
                    const y = center + (maxRadius + 10) * Math.sin(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(center, center);
                    ctx.lineTo(center + maxRadius * Math.cos(angle), center + maxRadius * Math.sin(angle));
                    ctx.stroke();
                    
                    ctx.fillStyle = '#1f2937';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.fillText(dir, x, y);
                });

                ctx.beginPath();
                const startPoint = getCoords(timeline[0].elevation, timeline[0].azimuth);
                ctx.moveTo(startPoint.x, startPoint.y);

                timeline.forEach(point => {
                    const coords = getCoords(point.elevation, point.azimuth);
                    ctx.lineTo(coords.x, coords.y);
                });

                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 3;
                ctx.stroke();

                const endPoint = getCoords(timeline[timeline.length - 1].elevation, timeline[timeline.length - 1].azimuth);
                
                // AOS (青)
                ctx.beginPath();
                ctx.arc(startPoint.x, startPoint.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#3b82f6'; // blue-500
                ctx.fill();
                ctx.fillStyle = '#3b82f6';
                ctx.fillText('AOS', startPoint.x, startPoint.y + 15);
                
                // LOS (赤)
                ctx.beginPath();
                ctx.arc(endPoint.x, endPoint.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#ef4444'; // red-500
                ctx.fill();
                ctx.fillStyle = '#ef4444';
                ctx.fillText('LOS', endPoint.x, endPoint.y + 15);

                // MAX (緑)
                let maxElPoint = timeline[0];
                let minTimeDiff = Math.abs(timeline[0].time.getTime() - pass.maxElevationTime.getTime());

                for (let i = 1; i < timeline.length; i++) {
                    const diff = Math.abs(timeline[i].time.getTime() - pass.maxElevationTime.getTime());
                    if (diff < minTimeDiff) {
                        minTimeDiff = diff;
                        maxElPoint = timeline[i];
                    }
                }
                
                if (maxElPoint) {
                    const maxPoint = getCoords(maxElPoint.elevation, maxElPoint.azimuth);
                    ctx.beginPath();
                    ctx.arc(maxPoint.x, maxPoint.y, 6, 0, 2 * Math.PI);
                    ctx.fillStyle = '#22c55e'; // green-500
                    ctx.fill();
                    ctx.fillStyle = '#22c55e';
                    ctx.fillText('MAX', maxPoint.x, maxPoint.y - 15);
                }
            }


            // --- (変更) リアルタイム追跡関数 ---

            function startRealTimeTracking() {
                if (!currentSatrec || !currentObserverGd || !currentSelectedPass) {
                    console.error("リアルタイム追跡を開始できません: 必要なデータが不足しています。");
                    return;
                }

                // 追跡モーダルを表示
                trackingModal.classList.remove('hidden');
                
                // (追加) パス情報をモーダルに設定
                trackingModalAosTime.textContent = formatTimeJST(currentSelectedPass.startTime, true);
                trackingModalLosTime.textContent = formatTimeJST(currentSelectedPass.endTime, true);
                trackingModalMaxEl.textContent = `${currentSelectedPass.maxElevation.toFixed(1)}°`;

                // 既存のインターバルをクリア
                if (realTimeTrackerInterval) {
                    clearInterval(realTimeTrackerInterval);
                }

                // 即時実行
                updateRealTimePosition(); 
                
                // 1秒ごとに位置を更新
                realTimeTrackerInterval = setInterval(updateRealTimePosition, 1000);
            }

            function stopRealTimeTracking() {
                // 追跡モーダルを非表示
                trackingModal.classList.add('hidden');
                
                // インターバルをクリア
                if (realTimeTrackerInterval) {
                    clearInterval(realTimeTrackerInterval);
                    realTimeTrackerInterval = null;
                }
                
                // 表示をリセット (変更)
                trackingModalEl.textContent = '--.-°';
                trackingModalAz.textContent = '--.-°';
                trackingModalAzCompass.textContent = '（--）';
                trackingModalCurrentTime.textContent = '--:--:--';
                trackingModalAosTime.textContent = '--:--:--';
                trackingModalLosTime.textContent = '--:--:--';
                trackingModalMaxEl.textContent = '--.-°';
            }

            function updateRealTimePosition() {
                if (!currentSatrec || !currentObserverGd) {
                    stopRealTimeTracking();
                    return;
                }

                try {
                    const now = new Date();
                    
                    // (追加) 現在時刻を更新
                    trackingModalCurrentTime.textContent = formatTimeJST(now, true) + " (JST)";

                    const positionAndVelocity = window.satellite.propagate(currentSatrec, now);
                    
                    if (!positionAndVelocity || !positionAndVelocity.position || !positionAndVelocity.velocity) {
                        throw new Error("現在の衛星位置の伝播(propagate)に失敗しました。");
                    }

                    const gmst = window.satellite.gstime(now);
                    const positionEcf = window.satellite.eciToEcf(positionAndVelocity.position, gmst);
                    const lookAngles = window.satellite.ecfToLookAngles(currentObserverGd, positionEcf);
                    
                    const elevation = window.satellite.radiansToDegrees(lookAngles.elevation);
                    const azimuth = window.satellite.radiansToDegrees(lookAngles.azimuth);

                    // モーダル内のテキストを更新
                    trackingModalEl.textContent = `${elevation.toFixed(1)}°`;
                    trackingModalAz.textContent = `${azimuth.toFixed(1)}°`;
                    trackingModalAzCompass.textContent = ''; // (変更) 方位表記を削除

                    // (もし仰角がマイナスになったら追跡を停止)
                    if (elevation < 0 && (!currentSelectedPass || now.getTime() > currentSelectedPass.endTime.getTime())) {
                        stopRealTimeTracking();
                    }

                } catch (error) {
                    console.error("リアルタイム追跡中にエラー:", error);
                    trackingModalEl.textContent = 'エラー';
                    trackingModalAz.textContent = 'エラー';
                    trackingModalAzCompass.textContent = `（${error.message}）`;
                    stopRealTimeTracking(); // エラーが発生したら停止
                }
            }


            // --- ヘルパー関数 ---

            function formatTimeJST(date, showSeconds = false) {
                const options = {
                    hour: '2-digit',
                    minute: '2-digit',
                    timeZone: 'Asia/Tokyo',
                    hour12: false
                };
                if (showSeconds) {
                    options.second = '2-digit';
                }
                return new Intl.DateTimeFormat('en-GB', options).format(date);
            }

            function formatDateJST(date) {
                return new Intl.DateTimeFormat('ja-JP', {
                    month: '2-digit',
                    day: '2-digit',
                    timeZone: 'Asia/Tokyo'
                }).format(date);
            }

            function azToCompass(az) {
                const directions = ['北', '北北東', '北東', '東北東', '東', '東南東', '南東', '南南東', '南', '南南西', '南西', '西南西', '西', '西北西', '北西', '北北西'];
                const index = Math.round(az / 22.5) % 16;
                return directions[index];
            }


            // --- ダウンロード関数 ---

            function capturePassDetail() {
                const captureTarget = document.getElementById('pass-detail-container');
                
                const options = {
                    scale: 2, 
                    useCORS: true, 
                    backgroundColor: '#ffffff',
                    scrollX: 0,
                    scrollY: -window.scrollY,
                };

                return html2canvas(captureTarget, options);
            }

            async function downloadPassDetailAsImage() {
                if (!selectedTLE.name) return;
                downloadErrorMessage.classList.add('hidden');
                
                try {
                    const canvas = await capturePassDetail();
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = `${selectedTLE.name.replace(/\s+/g, '_')}_pass_detail.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                } catch (error) {
                    console.error("画像キャプチャに失敗:", error);
                    downloadErrorMessage.textContent = "画像の生成に失敗しました。コンソールを確認してください。";
                    downloadErrorMessage.classList.remove('hidden');
                    setTimeout(() => downloadErrorMessage.classList.add('hidden'), 5000);
                }
            }

            async function downloadPassDetailAsPDF() {
                if (!selectedTLE.name) return;
                downloadErrorMessage.classList.add('hidden');

                try {
                    const { jsPDF } = window.jspdf;
                    const canvas = await capturePassDetail();
                    const imgData = canvas.toDataURL('image/jpeg', 0.8);
                    
                    const canvasWidth = canvas.width;
                    const canvasHeight = canvas.height;
                    
                    const a4Width = 297;
                    const a4Height = 210;
                    
                    const pdf = new jsPDF({
                        orientation: 'landscape',
                        unit: 'mm',
                        format: 'a4'
                    });

                    const margin = 5;
                    const usableWidth = a4Width - (margin * 2);
                    const usableHeight = a4Height - (margin * 2);
                    
                    const canvasAspect = canvasWidth / canvasHeight;
                    let pdfWidth, pdfHeight;

                    if (canvasAspect > (usableWidth / usableHeight)) {
                        pdfWidth = usableWidth;
                        pdfHeight = pdfWidth / canvasAspect;
                    } else {
                        pdfHeight = usableHeight;
                        pdfWidth = pdfHeight * canvasAspect;
                    }

                    const x = (a4Width - pdfWidth) / 2;
                    const y = (a4Height - pdfHeight) / 2;
                    
                    pdf.addImage(imgData, 'JPEG', x, y, pdfWidth, pdfHeight);
                    pdf.save(`${selectedTLE.name.replace(/\s+/g, '_')}_pass_detail.pdf`);

                } catch (error) {
                    console.error("PDFキャプチャに失敗:", error);
                    downloadErrorMessage.textContent = "PDFの生成に失敗しました。コンソールを確認してください。";
                    downloadErrorMessage.classList.remove('hidden');
                    setTimeout(() => downloadErrorMessage.classList.add('hidden'), 5000);
                }
            }


        }; // window.onload 終了
    </script>

</body>
</html>